// <auto-generated />
//
// To parse this JSON data, add NuGet 'System.Text.Json' then do:
//
//    using CevioCasts;
//
//    var definitions = Definitions.FromJson(jsonString);
#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603

namespace CevioCasts;

using System;
using System.Collections.Generic;

using System.Text.Json;
using System.Text.Json.Serialization;
using System.Globalization;

public partial class Definitions
{
	[JsonPropertyName("$schema")]
	public Uri Schema { get; set; }

	[JsonPropertyName("version")]
	public string Version { get; set; }

	[JsonPropertyName("casts")]
	public Cast[] Casts { get; set; }
}

public partial class Cast
{
	[JsonPropertyName("id")]
	public string Id { get; set; }

	[JsonPropertyName("cname")]
	public string Cname { get; set; }

	[JsonPropertyName("names")]
	public Name[] Names { get; set; }

	[JsonPropertyName("category")]
	public Category Category { get; set; }

	[JsonPropertyName("product")]
	public Product Product { get; set; }

	[JsonPropertyName("gender")]
	public Gender Gender { get; set; }

	[JsonPropertyName("lang")]
	public Lang Lang { get; set; }

	[JsonPropertyName("versions")]
	public string[] Versions { get; set; }

	[JsonPropertyName("hasEmotions")]
	public bool HasEmotions { get; set; }

	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyName("emotions")]
	public Emotion[] Emotions { get; set; }

	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyName("spSymbols")]
	public SpSymbol[] SpSymbols { get; set; }

	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyName("emotionOrder")]
	public EmotionOrder[] EmotionOrder { get; set; }
}

public partial class EmotionOrder
{
	[JsonPropertyName("version")]
	public string Version { get; set; }

	[JsonPropertyName("order")]
	public string[] Order { get; set; }
}

public partial class Emotion
{
	[JsonPropertyName("id")]
	public string Id { get; set; }

	[JsonPropertyName("names")]
	public Name[] Names { get; set; }
}

public partial class Name
{
	[JsonPropertyName("lang")]
	public Lang Lang { get; set; }

	[JsonPropertyName("display")]
	public string Display { get; set; }
}

public partial class SpSymbol
{
	[JsonPropertyName("id")]
	public string Id { get; set; }

	[JsonPropertyName("symbols")]
	public string[] Symbols { get; set; }

	[JsonPropertyName("names")]
	public Name[] Names { get; set; }
}

public enum Category { SingerSong, TextVocal };

public enum Lang { English, Japanese };

public enum Gender { Female, Male };

public enum Product { CeVIO_AI, CeVIO_CS, VoiSona };

public partial class Definitions
{
	public static Definitions FromJson(string json) => JsonSerializer.Deserialize<Definitions>(json, CevioCasts.Converter.Settings);
}

public static class Serialize
{
	public static string ToJson(this Definitions self) => JsonSerializer.Serialize(self, CevioCasts.Converter.Settings);
}

internal static class Converter
{
	public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)
	{
		Converters =
		{
			CategoryConverter.Singleton,
			LangConverter.Singleton,
			GenderConverter.Singleton,
			ProductConverter.Singleton,
			new DateOnlyConverter(),
			new TimeOnlyConverter(),
			IsoDateTimeOffsetConverter.Singleton
		},
	};
}

internal class CategoryConverter : JsonConverter<Category>
{
	public override bool CanConvert(Type t) => t == typeof(Category);

	public override Category Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var value = reader.GetString();
		switch (value)
		{
			case "SingerSong":
				return Category.SingerSong;
			case "TextVocal":
				return Category.TextVocal;
		}
		throw new Exception("Cannot unmarshal type Category");
	}

	public override void Write(Utf8JsonWriter writer, Category value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case Category.SingerSong:
				JsonSerializer.Serialize(writer, "SingerSong", options);
				return;
			case Category.TextVocal:
				JsonSerializer.Serialize(writer, "TextVocal", options);
				return;
		}
		throw new Exception("Cannot marshal type Category");
	}

	public static readonly CategoryConverter Singleton = new CategoryConverter();
}

internal class LangConverter : JsonConverter<Lang>
{
	public override bool CanConvert(Type t) => t == typeof(Lang);

	public override Lang Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var value = reader.GetString();
		switch (value)
		{
			case "English":
				return Lang.English;
			case "Japanese":
				return Lang.Japanese;
		}
		throw new Exception("Cannot unmarshal type Lang");
	}

	public override void Write(Utf8JsonWriter writer, Lang value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case Lang.English:
				JsonSerializer.Serialize(writer, "English", options);
				return;
			case Lang.Japanese:
				JsonSerializer.Serialize(writer, "Japanese", options);
				return;
		}
		throw new Exception("Cannot marshal type Lang");
	}

	public static readonly LangConverter Singleton = new LangConverter();
}

internal class GenderConverter : JsonConverter<Gender>
{
	public override bool CanConvert(Type t) => t == typeof(Gender);

	public override Gender Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var value = reader.GetString();
		switch (value)
		{
			case "Female":
				return Gender.Female;
			case "Male":
				return Gender.Male;
		}
		throw new Exception("Cannot unmarshal type Gender");
	}

	public override void Write(Utf8JsonWriter writer, Gender value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case Gender.Female:
				JsonSerializer.Serialize(writer, "Female", options);
				return;
			case Gender.Male:
				JsonSerializer.Serialize(writer, "Male", options);
				return;
		}
		throw new Exception("Cannot marshal type Gender");
	}

	public static readonly GenderConverter Singleton = new GenderConverter();
}

internal class ProductConverter : JsonConverter<Product>
{
	public override bool CanConvert(Type t) => t == typeof(Product);

	public override Product Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var value = reader.GetString();
		switch (value)
		{
			case "CeVIO AI":
				return Product.CeVIO_AI;
			case "CeVIO CS":
				return Product.CeVIO_CS;
			case "VoiSona":
				return Product.VoiSona;
		}
		throw new Exception("Cannot unmarshal type Product");
	}

	public override void Write(Utf8JsonWriter writer, Product value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case Product.CeVIO_AI:
				JsonSerializer.Serialize(writer, "CeVIO AI", options);
				return;
			case Product.CeVIO_CS:
				JsonSerializer.Serialize(writer, "CeVIO CS", options);
				return;
			case Product.VoiSona:
				JsonSerializer.Serialize(writer, "VoiSona", options);
				return;
		}
		throw new Exception("Cannot marshal type Product");
	}

	public static readonly ProductConverter Singleton = new ProductConverter();
}

public class DateOnlyConverter : JsonConverter<DateOnly>
{
	private readonly string serializationFormat;
	public DateOnlyConverter() : this(null) { }

	public DateOnlyConverter(string? serializationFormat)
	{
		this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
	}

	public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var value = reader.GetString();
		return DateOnly.Parse(value!);
	}

	public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
		=> writer.WriteStringValue(value.ToString(serializationFormat));
}

public class TimeOnlyConverter : JsonConverter<TimeOnly>
{
	private readonly string serializationFormat;

	public TimeOnlyConverter() : this(null) { }

	public TimeOnlyConverter(string? serializationFormat)
	{
		this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
	}

	public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var value = reader.GetString();
		return TimeOnly.Parse(value!);
	}

	public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
		=> writer.WriteStringValue(value.ToString(serializationFormat));
}

internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
{
	public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

	private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

	private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
	private string? _dateTimeFormat;
	private CultureInfo? _culture;

	public DateTimeStyles DateTimeStyles
	{
		get => _dateTimeStyles;
		set => _dateTimeStyles = value;
	}

	public string? DateTimeFormat
	{
		get => _dateTimeFormat ?? string.Empty;
		set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
	}

	public CultureInfo Culture
	{
		get => _culture ?? CultureInfo.CurrentCulture;
		set => _culture = value;
	}

	public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
	{
		string text;


		if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
			|| (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
		{
			value = value.ToUniversalTime();
		}

		text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

		writer.WriteStringValue(text);
	}

	public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		string? dateText = reader.GetString();

		if (string.IsNullOrEmpty(dateText) == false)
		{
			if (!string.IsNullOrEmpty(_dateTimeFormat))
			{
				return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
			}
			else
			{
				return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
			}
		}
		else
		{
			return default(DateTimeOffset);
		}
	}


	public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
}
#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603
